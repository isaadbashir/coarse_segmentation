import os
import numpy as np
from numpy.lib.stride_tricks import as_strided
from multiprocessing import Pool
import matplotlib.pyplot as plt
import pickle

# dataset path
patches_path = '/media/saad/HDD 1/OED/patches/10x/'

# output path =
patches_output_path = '/media/saad/HDD 1/OED/patches/10x_coarse/'

# filter size i.e., the window max will be taken and assigned
coarse_filter_size = 32

def create_coarse_patches(path):
    # print(path)

    # load the patch
    patch = np.load(path, allow_pickle=True)

    # seperate image and mask
    image, mask = patch[:, :, :3], patch[:, :, 3]

    # ori_mask = np.copy(mask)
    output_size = mask.shape[0]//coarse_filter_size

    coarse_mask = np.zeros((output_size,output_size))

    for i in range(0, mask.shape[0], coarse_filter_size):

        for j in range(0, mask.shape[1], coarse_filter_size):

            try:

                # deal with the corner cases where the size is not complete patch
                out_margin_y = 0
                out_margin_x = 0
                y_slice = i + coarse_filter_size
                x_slice = j + coarse_filter_size

                if mask.shape[0] + 1 <= y_slice:
                    out_margin_y = y_slice - mask.shape[0]
                    y_slice = y_slice - out_margin_y
                if mask.shape[1] + 1 <= x_slice:
                    out_margin_x = x_slice - mask.shape[1]
                    x_slice = x_slice - out_margin_x

                mask[i:y_slice - out_margin_y, j:x_slice - out_margin_x] = np.max(mask[i:y_slice - out_margin_y, j:x_slice - out_margin_x])
                coarse_mask[i//coarse_filter_size, j//coarse_filter_size] = np.max(mask[i:y_slice - out_margin_y, j:x_slice - out_margin_x])

            except Exception as ex:

                # deal with the corner cases where the size is not complete patch
                print(ex)

    patch_combo = np.dstack([image, mask])
    small_combo = {'img': image, 'mask': coarse_mask}


    patch_name = path.split('/')[-1]
    patch_split = path.split('/')[-2]

    # create the directories needed
    if not os.path.exists(f'{patches_output_path}/{coarse_filter_size}/{patch_split}'):
        os.makedirs(f'{patches_output_path}/{coarse_filter_size}/{patch_split}', exist_ok=True)

    # create the directories needed
    if not os.path.exists(f'{patches_output_path}/{coarse_filter_size}c/{patch_split}'):
        os.makedirs(f'{patches_output_path}/{coarse_filter_size}c/{patch_split}', exist_ok=True)

    np.save(f"{patches_output_path}/{coarse_filter_size}/{patch_split}/{patch_name}", patch_combo)

    with open(f'{patches_output_path}/{coarse_filter_size}c/{patch_split}/{patch_name[:-4]}.pkl', 'wb') as f:
        pickle.dump(small_combo, f, pickle.HIGHEST_PROTOCOL)

    # print(f'Processed the patch {path}')

    # plt.subplot(1,3,1)
    # plt.imshow(image)
    #
    # plt.subplot(1,3,2)
    # plt.imshow(coarse_mask)
    #
    # plt.subplot(1,3,3)
    # plt.imshow(mask)
    #
    # plt.show()

def main():
    # get list of all folders i.e., train, valid, test etc
    list_of_folders = os.listdir(patches_path)

    for split in list_of_folders:

        print(f'Starting the {split} folder .... ')
        list_of_patches = os.listdir(os.path.join(patches_path, split))

        # create_coarse_patches(os.path.join(patches_path, split, list_of_patches[0]))

        mp = Pool(16)
        mp.map(create_coarse_patches, [os.path.join(patches_path, split, i) for i in list_of_patches])




if __name__ == '__main__':
    main()


    
